<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tabuleiro Zen ‚Äì Jogo de Medita√ß√£o</title>
<style>
  :root{
    --bg-start:#e6f9ff; --bg-end:#d7f0ff;
    --card:#ffffff;
    --accent:#0d47a1; --accent-2:#1976d2; --muted:#5f6368;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
  body{
    background: linear-gradient(180deg,var(--bg-start),var(--bg-end));
    display:flex;flex-direction:column;align-items:center;padding:18px;
    color:#083248;
  }
  h1{margin:6px 0 2px;color:var(--accent);font-weight:800}
  .subtitle{color:var(--muted);margin-bottom:12px}

  /* Board container */
  .board-wrap{
    width:min(1100px,96vw); height:min(72vh,720px); position:relative; border-radius:18px; overflow:hidden;
    background: linear-gradient(180deg,#cfeeff,#eaf9ff);
    box-shadow: 0 14px 40px rgba(13,71,161,0.08);
    padding:20px;
  }

  /* Slight scene: floor shadow */
  .board-wrap::after{
    content:''; position:absolute; left:0; right:0; bottom:0; height:32px;
    background: linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.06));
    pointer-events:none;
  }

  /* cloud style using embedded svg as background */
  .cloud{
    position:absolute; width:120px; height:76px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="240" height="152" viewBox="0 0 240 152"><defs><filter id="a" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur in="SourceAlpha" stdDeviation="3" result="blur"/><feOffset dy="2"/><feComponentTransfer><feFuncA type="linear" slope="0.25"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><g filter="url(%23a)"><path fill="white" d="M62 116c-22 0-40-16-40-36 0-16 11-30 27-34 4-21 24-36 47-36 17 0 33 8 41 21 4-2 9-3 14-3 18 0 33 12 36 28 15 3 27 16 27 31 0 18-16 33-36 33H62z"/></g></svg>');
    background-size:cover; background-position:center;
    display:grid; place-items:center; cursor:grab; user-select:none;
    transition: transform .12s ease, box-shadow .12s ease;
  }
  .cloud:active{ cursor:grabbing; transform: scale(.995) }
  .cloud .label{
    background: rgba(255,255,255,.95); padding:6px 10px; border-radius:999px; font-weight:700; color:#06223a;
    box-shadow: 0 4px 12px rgba(0,0,0,.06); font-size:13px;
  }
  .cloud.start .label{ background:#c8e6c9 }
  .cloud.final .label{ background:#ffe082 }

  /* token (player piece) */
  .token{
    position:absolute; width:38px; height:38px; border-radius:999px; border:3px solid #fff;
    box-shadow:0 10px 22px rgba(0,0,0,.16); transform:translate(-50%,-100%);
    background-size:cover; background-position:center;
    transition: left .28s cubic-bezier(.2,.9,.3,1), top .28s cubic-bezier(.2,.9,.3,1);
    z-index:50; pointer-events:none;
  }
  .token.p1{ background: linear-gradient(135deg,#ffd6d6,#ef5350) }
  .token.p2{ background: linear-gradient(135deg,#e5dbff,#7e57c2) }

  /* UI area */
  .ui{ width:min(1100px,96vw); margin-top:14px; display:grid; gap:10px }
  .panel{ background:var(--card); border-radius:12px; padding:12px; box-shadow:0 10px 28px rgba(0,0,0,.06) }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  button{ border:0; background:var(--accent-2); color:#fff; padding:10px 12px; border-radius:10px; font-weight:700; cursor:pointer }
  button.secondary{ background:#90a4ae }
  button.warn{ background:#ef6c00 }
  button:disabled{ opacity:.6; cursor:not-allowed }
  .badge{ background:#f2f7fb; color:#103244; padding:6px 8px; border-radius:999px; font-weight:700 }

  .toast{ position:fixed; left:50%; bottom:24px; transform:translateX(-50%); background:#081420; color:#fff; padding:10px 14px; border-radius:10px; opacity:0; transition:opacity .18s ease; z-index:130 }
  .toast.show{ opacity:0.96 }

  /* overlay modal */
  .choice-overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.45); z-index:120 }
  .choice-card{ background:#fff; padding:14px; border-radius:10px; width:min(560px,92vw); box-shadow:0 20px 44px rgba(0,0,0,.22) }
  .choice-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(80px,1fr)); gap:8px; margin-top:8px }

  .restart-btn{
    position:fixed; right:18px; bottom:18px; z-index:140; padding:10px 12px; border-radius:10px;
    background:linear-gradient(135deg,#6ad1b6,#2ca58a); color:white; border:none; font-weight:800;
    box-shadow:0 10px 30px rgba(0,0,0,.12);
  }

  @media(max-width:640px){
    .token{ width:30px;height:30px }
    .cloud{ width:100px;height:64px }
  }
  
</style>
</head>
<body>

<h1>Tabuleiro Zen üßò‚Äç‚ôÇÔ∏è‚òÅÔ∏è</h1>

<div id="board" class="board-wrap" aria-label="Tabuleiro"></div>

<div class="ui">
  <div class="panel">
    <div class="row">
      <button id="rollBtn">üé≤ Rolar dado</button>
      <span id="diceValue" class="badge">‚Äî</span>
      <button id="hitBtn" class="secondary" disabled>‚úÖ Acertou</button>
      <button id="missBtn" class="warn" disabled>‚ùå Errou</button>
      <button id="restartBtn" class="secondary" style="margin-left:auto">üîÑ Jogar novamente</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div><b>Jogador atual:</b> <span id="turnLabel" class="badge">P1</span></div>
      <div><b>Posi√ß√µes:</b> <span id="posLabel" class="badge">P1: In√≠cio ‚Ä¢ P2: In√≠cio</span></div>
      <div><b>Estado:</b> <span id="stateLabel" class="badge">Pronto</span></div>
    </div>
  </div>

  <div class="panel rules">
    <details>
      <summary><b>Regras das casas</b></summary>
      <table style="width:100%; border-collapse:collapse; margin-top:8px">
        <thead><tr><th style="text-align:left">Casa</th><th style="text-align:left">Se acertar</th><th style="text-align:left">Se errar</th></tr></thead>
        <tbody>
          <tr><td>1</td><td>Avance +1 casa</td><td>Fique parado</td></tr>
          <tr><td>2</td><td>Ganhe 1 carta b√¥nus</td><td>Volte 1 casa</td></tr>
          <tr><td>3</td><td>Jogue novamente</td><td>Perca a pr√≥xima vez</td></tr>
          <tr><td>4</td><td>Avance at√© a Casa 6</td><td>Perda 1 rodada</td></tr>
          <tr><td>5</td><td>Avance +2 casas</td><td>Volte 2 casas</td></tr>
          <tr><td>6</td><td>Ganhe 1 carta b√¥nus</td><td>Perde a vez</td></tr>
          <tr><td>7</td><td>Ganhe imunidade de 1 erro</td><td>Perde a vez</td></tr>
          <tr><td>8</td><td>Jogue 2 vezes seguidas</td><td>Espere 1 rodada</td></tr>
          <tr><td>9</td><td>V√° para a Casa 13</td><td>‚Äî</td></tr>
          <tr><td>10</td><td>Avance +1 casa</td><td>‚Äî</td></tr>
          <tr><td>11</td><td>Escolha qualquer casa</td><td>Volte uma rodada</td></tr>
          <tr><td>12</td><td>Ganhe 1 carta b√¥nus</td><td>Volte 1 casa</td></tr>
          <tr><td>13</td><td>Avance para a Casa Final</td><td>‚Äî</td></tr>
          <tr><td>Final</td><td>Vence se acertar a pergunta</td><td>Volte para a Casa 10</td></tr>
        </tbody>
      </table>
    </details>
  </div>
</div>

<div id="toast" class="toast" aria-hidden="true"></div>

<!-- overlay modal -->
<div id="overlay" class="choice-overlay" role="dialog" aria-hidden="true">
  <div class="choice-card">
    <h3 id="overlayTitle">Escolha</h3>
    <div id="overlayBody"></div>
    <div style="text-align:right; margin-top:10px">
      <button id="overlayClose" class="secondary">Fechar</button>
    </div>
  </div>
</div>

<script>
/* ---------------- constants & DOM ---------------- */
const LS_KEYS = { CLOUDS: 'zen_cloud_positions_v1', GAME: 'zen_game_state_v1' };
const FINAL_IDX = 14;
const board = document.getElementById('board');
const overlay = document.getElementById('overlay');
const overlayBody = document.getElementById('overlayBody');
const overlayTitle = document.getElementById('overlayTitle');
const toastEl = document.getElementById('toast');

/* ---------------- small UI helpers ---------------- */
function toast(msg){
  toastEl.textContent = msg; toastEl.classList.add('show'); toastEl.setAttribute('aria-hidden','false');
  clearTimeout(toastEl._h); toastEl._h = setTimeout(()=>{ toastEl.classList.remove('show'); toastEl.setAttribute('aria-hidden','true'); }, 1400);
}
function $(sel){ return document.querySelector(sel); }

/* ---------------- game state ---------------- */
let state = {
  clouds: [],
  players: [
    { pos:0, skip:0, extra:0, immune:0, bonuses:[] },
    { pos:0, skip:0, extra:0, immune:0, bonuses:[] }
  ],
  turn: 0,
  phase: 'idle',
  lastRoll: null,
};

/* ---------------- bonus deck (simple) ---------------- */
const bonusDeck = [
  { id:'adv1', label:'Avance +1', run:(p)=> { p.pos = Math.min(FINAL_IDX, p.pos+1); toast('Avan√ßou +1'); } },
  { id:'adv2', label:'Avance +2', run:(p)=> { p.pos = Math.min(FINAL_IDX, p.pos+2); toast('Avan√ßou +2'); } },
  { id:'reroll', label:'Role novamente', run:(p)=> { p.extra = (p.extra || 0) + 1; toast('Voc√™ pode rolar novamente!'); } },
  { id:'immune', label:'Imunidade (1 erro)', run:(p)=> { p.immune = (p.immune || 0) + 1; toast('Imunidade adquirida'); } },
];

function drawBonus(player){
  const card = bonusDeck[Math.floor(Math.random()*bonusDeck.length)];
  player.bonuses = player.bonuses || [];
  player.bonuses.push(card);
  // aplicar imediato para simplicidade
  if(card.run) card.run(player);
  saveGame();
}

/* ---------------- layout helpers ---------------- */
function orderedPathLayout(){
  const w = board.clientWidth || 1000;
  const h = board.clientHeight || 600;
  const cols = 5, rows = 3;
  const padX = 40, padY = 40;
  const cellW = (w - padX*2) / (cols-1);
  const cellH = (h - padY*2) / (rows-1);
  const coords = [];
  for(let r=0;r<rows;r++){
    const rowYs = padY + r*cellH;
    if(r % 2 === 0){
      for(let c=0;c<cols;c++){
        const x = Math.round(padX + c*cellW + (Math.random()-0.5)*20);
        const y = Math.round(rowYs + (Math.random()-0.5)*18);
        coords.push({x,y});
      }
    } else {
      for(let c=cols-1;c>=0;c--){
        const x = Math.round(padX + c*cellW + (Math.random()-0.5)*20);
        const y = Math.round(rowYs + (Math.random()-0.5)*18);
        coords.push({x,y});
      }
    }
  }
  return coords.slice(0,15);
}

/* ---------------- DOM cloud creation & drag ---------------- */
function createCloudElement(id,label){
  const el = document.createElement('div');
  el.className = 'cloud';
  el.dataset.id = id;
  if(id===0) el.classList.add('start');
  if(id===FINAL_IDX) el.classList.add('final');
  const span = document.createElement('div'); span.className = 'label'; span.textContent = label;
  el.appendChild(span);
  enableDrag(el);
  return el;
}

function enableDrag(el){
  let dragging=false, offsetX=0, offsetY=0;
  el.style.touchAction = 'none';
  el.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    dragging = true;
    el.setPointerCapture(e.pointerId);
    const rect = el.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    el.style.transition = 'none';
  });
  el.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const brect = board.getBoundingClientRect();
    let x = e.clientX - brect.left - offsetX;
    let y = e.clientY - brect.top - offsetY;
    x = Math.max(8, Math.min(board.clientWidth - 128, x));
    y = Math.max(8, Math.min(board.clientHeight - 84, y));
    placeCloud(+el.dataset.id, x, y);
  });
  el.addEventListener('pointerup', (e)=>{
    if(!dragging) return;
    dragging = false;
    el.releasePointerCapture(e.pointerId);
    el.style.transition = '';
    saveClouds();
  });
  el.addEventListener('pointercancel', ()=>{ dragging=false; });
}

function placeCloud(id,x,y){
  if(!state.clouds[id]) return;
  state.clouds[id].x = x; state.clouds[id].y = y;
  if(state.clouds[id].el) { state.clouds[id].el.style.left = x + 'px'; state.clouds[id].el.style.top = y + 'px'; }
  // move tokens standing on this cloud
  state.players.forEach((p, idx) => {
    if(p.pos === id){
      const t = document.querySelector('.token.p'+(idx+1));
      if(t) { t.style.left = (x + 60) + 'px'; t.style.top = (y + (idx===0?10:34)) + 'px'; }
    }
  });
}

/* ---------------- tokens ---------------- */
function ensureTokens(){
  for(let i=0;i<2;i++){
    if(!document.querySelector(`.token.p${i+1}`)){
      const t = document.createElement('div'); t.className = `token p${i+1}`; board.appendChild(t);
    }
  }
}
function positionTokens(){
  ensureTokens();
  state.players.forEach((p, idx) => {
    const cloud = state.clouds[p.pos];
    const t = document.querySelector('.token.p'+(idx+1));
    if(cloud && t){
      t.style.left = (cloud.x + 60) + 'px';
      t.style.top  = (cloud.y + (idx===0 ? 10 : 34)) + 'px';
    }
  });
}

/* ---------------- persistence ---------------- */
function saveClouds(){
  try {
    const arr = state.clouds.map(c => ({x:c.x,y:c.y}));
    localStorage.setItem(LS_KEYS.CLOUDS, JSON.stringify(arr));
  } catch(e){ console.warn('save clouds failed', e); }
}
function saveGame(){
  try {
    const data = { players: state.players, turn: state.turn, phase: state.phase, lastRoll: state.lastRoll };
    localStorage.setItem(LS_KEYS.GAME, JSON.stringify(data));
  } catch(e){ console.warn('save game failed', e); }
}
function loadGame(){
  let okClouds=false;
  try {
    const raw = localStorage.getItem(LS_KEYS.CLOUDS);
    if(raw){
      const parsed = JSON.parse(raw);
      if(Array.isArray(parsed) && parsed.length===15 && parsed.every(it => typeof it.x === 'number' && typeof it.y === 'number')){
        state.clouds = parsed.map((p,i)=>({ id:i, x:p.x, y:p.y }));
        okClouds = true;
      }
    }
  } catch(e){ okClouds=false; }

  try {
    const rawg = localStorage.getItem(LS_KEYS.GAME);
    if(rawg){
      const parsed = JSON.parse(rawg);
      if(parsed && Array.isArray(parsed.players) && parsed.players.length===2){
        state.players = parsed.players.map((pl,i)=>({
          pos: (typeof pl.pos === 'number' && pl.pos >=0 && pl.pos <= FINAL_IDX) ? pl.pos : 0,
          skip: pl.skip||0, extra: pl.extra||0, immune: pl.immune||0, bonuses: pl.bonuses||[]
        }));
        state.turn = typeof parsed.turn === 'number' ? parsed.turn : 0;
        state.phase = parsed.phase || 'idle';
        state.lastRoll = parsed.lastRoll || null;
      }
    }
  } catch(e){ /* ignore */ }
  return okClouds;
}

/* ---------------- game actions ---------------- */
function movePlayer(p, delta){
  p.pos = Math.max(0, Math.min(FINAL_IDX, p.pos + delta));
  positionTokens();
  updateLabels();
  saveGame();
}
function teleportPlayer(p, idx){
  p.pos = Math.max(0, Math.min(FINAL_IDX, idx));
  positionTokens();
  updateLabels();
  saveGame();
}

/* ---------- House rules (correct/incorrect) ---------- */
function chooseHouse(cb){
  overlayTitle.textContent = 'Escolha para qual casa ir';
  overlayBody.innerHTML = '';
  const grid = document.createElement('div'); 
  grid.className = 'choice-grid';

  for(let i=0;i<=FINAL_IDX;i++){
    const b = document.createElement('button'); 
    b.textContent = i===0 ? 'In√≠cio' : (i===FINAL_IDX ? 'Final' : String(i));
    b.addEventListener('click', ()=>{ 
      overlay.style.display='none'; 
      overlay.setAttribute('aria-hidden','true');
      cb(i); 
      enableRoll(true);
      saveGame();
      updateLabels();
    });
    grid.appendChild(b);
  }

  overlayBody.appendChild(grid);
  overlay.style.display='flex';
  overlay.setAttribute('aria-hidden','false');
}

document.getElementById('overlayClose').addEventListener('click', ()=>{
  overlay.style.display='none';
  overlay.setAttribute('aria-hidden','true');
  enableRoll(true);
});

/* show final question modal */
function showFinalQuestion(cb){
  overlayTitle.textContent = 'Pergunta Final üßò‚Äç‚ôÄÔ∏è';
  overlayBody.innerHTML = `
    <p>Para vencer o jogo, responda corretamente:</p>
    <p><b>O que significa meditar?</b></p>
    <div class="choice-grid">
      <button>Relaxar completamente o corpo</button>
      <button>Ficar sem pensar em nada</button>
      <button>Observar os pensamentos sem se apegar</button>
      <button>Dormir profundamente</button>
    </div>
  `;

  const buttons = overlayBody.querySelectorAll('button');
  buttons.forEach(btn=>{
    btn.addEventListener('click',()=>{
      const correct = btn.textContent.includes('Observar');
      overlay.style.display='none';
      overlay.setAttribute('aria-hidden','true');
      cb(correct);
    });
  });

  overlay.style.display='flex';
  overlay.setAttribute('aria-hidden','false');
}

/* ---------- MAIN: applyHouseRule with correct behavior ---------- */
function applyHouseRule(correct){
  const player = state.players[state.turn];
  const pos = player.pos;

  // helpers
  const move = (delta)=>{ movePlayer(player, delta); };
  const teleport = (idx)=>{ teleportPlayer(player, idx); };
  const addBonus = ()=>{ drawBonus(player); };
  const giveImmunity = ()=>{ player.immune = (player.immune||0) + 1; toast('Imunidade concedida'); };
  const addExtra = (n=1)=>{ player.extra = (player.extra||0) + n; toast(`+${n} jogada(s) extra`); };
  const addSkip = (n=1)=>{ player.skip = (player.skip||0) + n; toast(`Pular√° ${n} rodada(s)`); };

  // no rule for start
  if(pos === 0) { saveGame(); updateLabels(); return; }

  // if player has immunity and errou => consume immunity and treat as correct
  if(!correct && (player.immune||0) > 0){
    player.immune -= 1;
    toast('Imunidade usada ‚Äî penalidade ignorada.');
    correct = true;
  }

  if(correct){
    switch(pos){
      case 1: move(+1); break;
      case 2: addBonus(); break;
      case 3: addExtra(1); toast('Voc√™ jogar√° novamente'); break; // extra allows another roll before passing
      case 4: teleport(6); break;
      case 5: move(+2); break;
      case 6: addBonus(); break;
      case 7: giveImmunity(); break;
      case 8: addExtra(2); toast('Voc√™ ter√° duas jogadas seguidas'); break;
      case 9: teleport(13); break;
      case 10: move(+1); break;
      case 11:
        // choose a house via modal; after choice, do not advance turn automatically here
        chooseHouse((idx)=>{
          teleport(idx);
          saveGame();
          updateLabels();
        });
        // return so we don't advance turn twice
        return;
      case 12: addBonus(); break;
      case 13: teleport(FINAL_IDX); break;
      case FINAL_IDX:
        // final question modal ‚Äî handle victory inside modal callback
        showFinalQuestion((win)=>{
          if(win){
            toast('üéâ Vit√≥ria! Jogador ' + (state.turn+1));
            // show restart button
            showRestartButton();
            // disable further interaction
            enableRoll(false);
            $('#hitBtn').disabled = true; $('#missBtn').disabled = true;
            state.phase = 'finished';
            saveGame();
          } else {
            toast('Errou! Volte para a Casa 10');
            teleport(10);
            saveGame();
            updateLabels();
          }
        });
        return;
    }
  } else {
    switch(pos){
      case 1: toast('Fique parado'); break;
      case 2: move(-1); break;
      case 3: addSkip(1); toast('Voc√™ perder√° a pr√≥xima vez'); break;
      case 4: addSkip(1); toast('Perder√° 1 rodada'); break;
      case 5: move(-2); break;
      case 6: addSkip(1); toast('Perde a vez'); break;
      case 7: addSkip(1); toast('Perde a vez'); break;
      case 8: addSkip(1); toast('Espere 1 rodada'); break;
      case 9: toast('Sem penalidade definida'); break;
      case 10: toast('Sem penalidade'); break;
      case 11: addSkip(1); toast('Volta uma rodada (perde a pr√≥xima)'); break;
      case 12: move(-1); break;
      case 13: toast('Nada acontece'); break;
      case FINAL_IDX:
        toast('Volte para a Casa 10');
        teleport(10);
        break;
    }
  }

  // after applying rule, save state and update labels
  saveGame();
  updateLabels();
}

/* ---------- advance turn logic ---------- */
function advanceTurn(){
  // if current player has extra moves, let them go again (consume 1 extra)
  const current = state.players[state.turn];
  if(current.extra && current.extra > 0){
    current.extra -= 1;
    toast('Jogada extra ‚Äî voc√™ joga novamente');
    saveGame();
    updateLabels();
    return; // same player's turn
  }

  // otherwise pass to next, respecting skip counters
  let next = (state.turn + 1) % 2;
  let attempts = 0;
  while(attempts < 4){
    const p = state.players[next];
    if(p.skip && p.skip > 0){
      // consume skip and pass to next
      p.skip -= 1;
      toast(`Jogador ${next+1} perde a vez (skip aplicado).`);
      saveGame();
      next = (next + 1) % 2;
      attempts++;
      continue;
    }
    break;
  }
  state.turn = next;
  saveGame();
  updateLabels();
}

/* ---------- utility to show restart button ---------- */
function showRestartButton(){
  if(document.querySelector('.restart-btn')) return;
  const btn = document.createElement('button');
  btn.textContent = 'üîÅ Jogar Novamente';
  btn.className = 'restart-btn';
  btn.addEventListener('click', ()=>{
    if(!confirm('Reiniciar jogo?')) return;
    // reset game state but keep cloud layout
    state.players = [
      { pos:0, skip:0, extra:0, immune:0, bonuses:[] },
      { pos:0, skip:0, extra:0, immune:0, bonuses:[] }
    ];
    state.turn = 0; state.phase = 'idle'; state.lastRoll = null;
    saveGame();
    positionTokens();
    updateLabels();
    toast('Jogo reiniciado (layout preservado).');
    btn.remove();
    enableRoll(true);
  });
  document.body.appendChild(btn);
}

/* ---------- UI helpers & events ---------- */
function updateLabels(){
  document.getElementById('turnLabel').textContent = state.turn === 0 ? 'P1' : 'P2';
  const n = i => i===0 ? 'In√≠cio' : (i===FINAL_IDX ? 'Final' : String(i));
  document.getElementById('posLabel').textContent = `P1: ${n(state.players[0].pos)} ‚Ä¢ P2: ${n(state.players[1].pos)}`;
  const p = state.players[state.turn];
  const tags = [];
  if(p.skip>0) tags.push(`pula: ${p.skip}`);
  if(p.extra>0) tags.push(`extras: ${p.extra}`);
  if(p.immune>0) tags.push(`imunidade: ${p.immune}`);
  if(p.bonuses && p.bonuses.length>0) tags.push(`b√¥nus: ${p.bonuses.map(b=>b.label).join(', ')}`);
  document.getElementById('stateLabel').textContent = tags.length ? tags.join(' | ') : 'Pronto';
}

function enableRoll(flag){
  document.getElementById('rollBtn').disabled = !flag;
  // hit/miss should be enabled when waiting for response; control elsewhere
}

/* ---------- dice & controls ---------- */
function rollDice(){ return 1 + Math.floor(Math.random()*4); }

document.getElementById('rollBtn').addEventListener('click', ()=>{
  const p = state.players[state.turn];
  if(p.skip && p.skip > 0){
    p.skip -= 1;
    toast('Voc√™ perdeu esta rodada.');
    saveGame();
    advanceTurn();
    updateLabels();
    return;
  }
  const val = rollDice();
  state.lastRoll = val; document.getElementById('diceValue').textContent = String(val);
  // move token immediately
  movePlayer(p, val);
  // enable hit/miss
  document.getElementById('hitBtn').disabled = false;
  document.getElementById('missBtn').disabled = false;
  // disable roll while awaiting result
  document.getElementById('rollBtn').disabled = true;
  saveGame();
  toast(`Voc√™ tirou ${val}`);
});

document.getElementById('hitBtn').addEventListener('click', ()=>{
  const p = state.players[state.turn];
  // disable answer buttons
  document.getElementById('hitBtn').disabled = true;
  document.getElementById('missBtn').disabled = true;
  // apply rule (correct)
  applyHouseRule(true);
  // if player has extras (player.extra), keep same player; else advance
  if(p.extra && p.extra > 0){
    // let player play again; roll button enabled
    document.getElementById('rollBtn').disabled = false;
    p.extra -= 1;
    toast('Voc√™ tem jogadas extras ‚Äî role novamente.');
    saveGame();
    updateLabels();
    return;
  }
  // otherwise advance turn normally
  advanceTurn();
  document.getElementById('rollBtn').disabled = false;
});

document.getElementById('missBtn').addEventListener('click', ()=>{
  const p = state.players[state.turn];
  // disable answer buttons
  document.getElementById('hitBtn').disabled = true;
  document.getElementById('missBtn').disabled = true;
  applyHouseRule(false);
  // if player has extras, consume or else advance
  if(p.extra && p.extra > 0){
    p.extra -= 1;
    document.getElementById('rollBtn').disabled = false;
    toast('Voc√™ tem jogadas extras ‚Äî role novamente.');
    saveGame();
    updateLabels();
    return;
  }
  advanceTurn();
  document.getElementById('rollBtn').disabled = false;
});

document.getElementById('restartBtn').addEventListener('click', ()=>{
  if(!confirm('Tem certeza que deseja reiniciar o jogo?')) return;
  // reset players but keep cloud layout
  state.players = [
    { pos:0, skip:0, extra:0, immune:0, bonuses:[] },
    { pos:0, skip:0, extra:0, immune:0, bonuses:[] }
  ];
  state.turn = 0; state.phase = 'idle'; state.lastRoll = null;
  saveGame();
  positionTokens();
  updateLabels();
  toast('Jogo reiniciado (layout das nuvens preservado).');
  // remove restart button if present
  const rb = document.querySelector('.restart-btn'); if(rb) rb.remove();
});

/* ---------- initialization & rendering ---------- */
function loadAndRender(){
  const cloudsOk = loadGame();
  if(!cloudsOk || !Array.isArray(state.clouds) || state.clouds.length !== 15){
    const layout = orderedPathLayout();
    state.clouds = layout.map((p,i)=>({ id:i, x:p.x, y:p.y }));
    saveClouds();
  } else {
    state.clouds = state.clouds.map((c,i)=>({ id:i, x: c.x, y: c.y }));
  }

  // create dom clouds and place them
  state.clouds.forEach(c=>{
    const label = c.id === 0 ? 'In√≠cio' : (c.id === FINAL_IDX ? 'Final' : String(c.id));
    const el = createCloudElement(c.id, label);
    board.appendChild(el);
    c.el = el;
    placeCloud(c.id, c.x, c.y);
  });

  // ensure players positions valid
  state.players.forEach((p,i)=>{
    if(typeof p.pos !== 'number' || p.pos < 0 || p.pos > FINAL_IDX) p.pos = 0;
  });

  ensureTokens();
  positionTokens();
  updateLabels();
  document.getElementById('rollBtn').disabled = false;
}

loadAndRender();
</script>
</body>
</html>
